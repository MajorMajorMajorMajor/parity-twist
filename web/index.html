<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Parity Twist</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

:root {
  --bg: #0f0e17;
  --surface: #1a1a2e;
  --surface2: #16213e;
  --p1: #4ecca3;
  --p2: #e94560;
  --key: #0f3460;
  --key-light: #3a86ff;
  --text: #eaeaea;
  --text-dim: #8892a0;
  --gold: #ffd700;
  --win-glow: rgba(78, 204, 163, 0.25);
  --lose-glow: rgba(233, 69, 96, 0.25);
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow-x: hidden;
  padding: 12px;
  user-select: none;
}

h1 {
  font-size: 1.6rem;
  font-weight: 700;
  letter-spacing: 2px;
  margin: 8px 0 4px;
  background: linear-gradient(135deg, var(--p1), var(--key-light), var(--p2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.subtitle {
  font-size: 0.75rem;
  color: var(--text-dim);
  margin-bottom: 12px;
}

/* Turn indicator */
.turn-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 8px 20px;
  border-radius: 20px;
  background: var(--surface);
  margin-bottom: 14px;
  font-size: 0.95rem;
  font-weight: 600;
  transition: all 0.3s;
}
.turn-bar.p1-turn { border: 2px solid var(--p1); }
.turn-bar.p2-turn { border: 2px solid var(--p2); }
.turn-bar .dot {
  width: 10px; height: 10px;
  border-radius: 50%;
  transition: background 0.3s;
}
.turn-bar.p1-turn .dot { background: var(--p1); }
.turn-bar.p2-turn .dot { background: var(--p2); }

/* Scoreboard (shown at end of game) */
.scoreboard {
  display: none;
  flex-direction: column;
  align-items: center;
  margin-bottom: 10px;
  animation: fadeIn 0.4s;
}
.scoreboard.show { display: flex; }
.scoreboard-title {
  font-size: 2rem;
  font-weight: 800;
  letter-spacing: 2px;
}
.scoreboard-score {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--text-dim);
  margin-top: 2px;
}

/* Game board */
.board-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0;
  transition: transform 0.4s, margin-bottom 0.4s;
}
.board-container.endgame {
  transform: scale(0.82);
  transform-origin: top center;
  margin-bottom: -55px;
}

.col-headers {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  width: 270px;
  margin-bottom: 4px;
}
.col-headers span {
  text-align: center;
  font-size: 0.8rem;
  font-weight: 700;
  letter-spacing: 1px;
}
.col-headers .h-p1 { color: var(--p1); }
.col-headers .h-p2 { color: var(--p2); }
.col-headers .h-key { color: var(--key-light); }

.grid {
  display: grid;
  grid-template-columns: repeat(3, 90px);
  grid-template-rows: repeat(var(--rows, 3), 72px);
  gap: 0;
  border: 2px solid #2a2a4a;
  border-radius: 10px;
  overflow: hidden;
  background: #2a2a4a;
}

.cell {
  background: var(--surface);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.6rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  border: 1px solid #2a2a4a;
  position: relative;
}
.cell:active { transform: scale(0.95); }
.cell.selected {
  background: var(--surface2);
  box-shadow: inset 0 0 20px rgba(58, 134, 255, 0.3);
}
.cell.filled { cursor: default; }
.cell.filled:active { transform: none; }
.cell.locked {
  opacity: 0.55;
  box-shadow: inset 0 0 0 2px rgba(255, 215, 0, 0.35);
}

.cell.col-0 { color: var(--p1); }
.cell.col-1 { color: var(--p2); }
.cell.col-2 { color: var(--key-light); }

/* Row result indicators */
.cell.row-win { box-shadow: inset 0 0 20px var(--win-glow); }
.cell.row-lose { box-shadow: inset 0 0 20px var(--lose-glow); }

/* Row labels */
.row-labels {
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  margin-left: 6px;
}

/* Master Key */
.master-key-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 6px;
}
.master-key-slots {
  display: flex;
  gap: 8px;
  align-items: center;
}
.master-key-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.master-key-label {
  font-size: 0.7rem;
  color: var(--text-dim);
  letter-spacing: 1px;
  margin-bottom: 3px;
}
.master-key-cell {
  width: 90px;
  height: 72px;
  background: var(--surface);
  border: 2px solid var(--key);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.6rem;
  font-weight: 700;
  color: var(--gold);
  cursor: pointer;
  transition: all 0.2s;
}
.master-key-cell:active { transform: scale(0.95); }
.master-key-cell.selected {
  background: var(--surface2);
  box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.2);
  border-color: var(--gold);
}
.master-key-cell.filled { cursor: default; }
.master-key-cell.filled:active { transform: none; }

/* Number picker */
.picker-label {
  font-size: 0.75rem;
  color: var(--text-dim);
  margin: 14px 0 6px;
  letter-spacing: 1px;
}
.number-picker {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  width: 280px;
}
.num-btn {
  width: 48px;
  height: 44px;
  border: 2px solid #2a2a4a;
  border-radius: 10px;
  background: var(--surface);
  color: var(--text);
  font-size: 1.1rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.num-btn:active { transform: scale(0.92); }
.num-btn.used {
  opacity: 0.2;
  cursor: default;
  text-decoration: line-through;
}
.num-btn.used:active { transform: none; }
.num-btn.p1-placed { border-color: var(--p1); color: var(--p1); opacity: 0.4; }
.num-btn.p2-placed { border-color: var(--p2); color: var(--p2); opacity: 0.4; }
.num-btn.key-placed { border-color: var(--key-light); color: var(--key-light); opacity: 0.4; }
.num-btn.mk-placed { border-color: var(--gold); color: var(--gold); opacity: 0.4; }

/* Action buttons */
.actions {
  display: flex;
  gap: 10px;
  margin-top: 14px;
}
.btn {
  padding: 10px 22px;
  border: none;
  border-radius: 10px;
  font-size: 0.9rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  letter-spacing: 1px;
}
.btn:active { transform: scale(0.95); }
.btn-primary {
  background: linear-gradient(135deg, var(--p1), var(--key-light));
  color: var(--bg);
}
.btn-secondary {
  background: var(--surface);
  color: var(--text);
  border: 2px solid #2a2a4a;
}
.btn-help {
  background: var(--surface);
  color: var(--text-dim);
  border: 2px solid #2a2a4a;
  font-size: 0.8rem;
  padding: 8px 14px;
}

/* Endgame breakdown */
.endgame-breakdown {
  display: none;
  flex-direction: column;
  gap: 5px;
  width: 310px;
  margin-top: 8px;
  animation: fadeIn 0.4s;
}
.endgame-breakdown.show { display: flex; }
.breakdown-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 7px 10px;
  border-radius: 8px;
  background: var(--surface);
  font-size: 0.78rem;
}
.breakdown-label {
  font-weight: 700;
  min-width: 44px;
}
.breakdown-rule {
  flex: 1;
  color: var(--text-dim);
  font-size: 0.7rem;
}
.breakdown-winner {
  font-size: 0.68rem;
  font-weight: 700;
  padding: 2px 8px;
  border-radius: 10px;
}
.breakdown-winner.bw-p1 { background: var(--p1); color: var(--bg); }
.breakdown-winner.bw-p2 { background: var(--p2); color: white; }

/* Endgame actions */
.endgame-actions {
  display: none;
  gap: 10px;
  margin-top: 14px;
  animation: fadeIn 0.4s;
}
.endgame-actions.show { display: flex; }

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

/* Help modal */
.help-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 14, 23, 0.95);
  z-index: 200;
  overflow-y: auto;
  padding: 20px;
  animation: fadeIn 0.3s;
}
.help-overlay.show { display: block; }
.help-content {
  background: var(--surface);
  border-radius: 16px;
  padding: 24px;
  max-width: 360px;
  margin: 0 auto;
  font-size: 0.82rem;
  line-height: 1.6;
  color: var(--text-dim);
}
.help-content h2 {
  color: var(--text);
  font-size: 1.2rem;
  margin-bottom: 12px;
}
.help-content h3 {
  color: var(--text);
  font-size: 0.95rem;
  margin: 14px 0 6px;
}
.help-content .hl-p1 { color: var(--p1); font-weight: 700; }
.help-content .hl-p2 { color: var(--p2); font-weight: 700; }
.help-content .hl-key { color: var(--key-light); font-weight: 700; }
.help-content .hl-mk { color: var(--gold); font-weight: 700; }
.help-close {
  margin-top: 16px;
  width: 100%;
}

/* Animations */
@keyframes pop {
  0% { transform: scale(0.5); opacity: 0; }
  60% { transform: scale(1.15); }
  100% { transform: scale(1); opacity: 1; }
}
.cell-pop { animation: pop 0.3s ease-out; }

/* Row result arrows / indicators on board */
.row-indicator {
  position: absolute;
  right: -28px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 1.2rem;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Board wrapper with row indicators */
.board-with-indicators {
  display: flex;
  align-items: flex-start;
  gap: 0;
}

.row-indicators {
  display: flex;
  flex-direction: column;
  margin-left: 8px;
}
.row-ind-item {
  height: 72px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.65rem;
  font-weight: 700;
  width: 40px;
  border-radius: 6px;
  opacity: 0;
  transition: opacity 0.4s;
}
.row-ind-item.show { opacity: 1; }
.row-ind-item.p1w { color: var(--p1); background: rgba(78, 204, 163, 0.1); }
.row-ind-item.p2w { color: var(--p2); background: rgba(233, 69, 96, 0.1); }

/* Parity hint at bottom */
.parity-hint {
  margin-top: 10px;
  font-size: 0.72rem;
  color: var(--text-dim);
  text-align: center;
  min-height: 2.5em;
  padding: 4px 10px;
  border-radius: 8px;
  background: var(--surface);
  width: 290px;
  line-height: 1.4;
}
.parity-hint .even { color: var(--key-light); }
.parity-hint .odd { color: var(--p2); }
.parity-hint .low { color: var(--p1); }
.parity-hint .high { color: var(--gold); }

/* Menu overlay */
.menu-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg);
  z-index: 300;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.4s;
}
.menu-overlay.show { display: flex; }
.menu-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}
.menu-title {
  font-size: 2.2rem;
  font-weight: 700;
  letter-spacing: 3px;
  background: linear-gradient(135deg, var(--p1), var(--key-light), var(--p2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 0;
}
.menu-sub {
  font-size: 0.8rem;
  color: var(--text-dim);
  letter-spacing: 2px;
  margin-bottom: 20px;
}
.menu-btn {
  width: 200px;
  padding: 14px;
  font-size: 1rem;
  text-align: center;
  border: none;
}
.menu-btn-vs {
  background: linear-gradient(135deg, var(--p1), var(--key-light));
  color: var(--bg);
}
.menu-btn-ai {
  background: linear-gradient(135deg, var(--p2), #ff6b6b);
  color: white;
}
.difficulty-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  margin-top: 4px;
  animation: fadeIn 0.3s;
}
.diff-label {
  font-size: 0.75rem;
  color: var(--text-dim);
  letter-spacing: 1px;
}
.diff-btn {
  width: 180px;
  padding: 11px;
  font-size: 0.85rem;
  background: var(--surface);
  color: var(--text);
  border: 2px solid #2a2a4a;
  text-align: center;
}
.diff-btn:hover { border-color: var(--p2); }
.menu-select {
  width: 220px;
  padding: 10px;
  border-radius: 10px;
  border: 2px solid #2a2a4a;
  background: var(--surface);
  color: var(--text);
  font-size: 0.85rem;
}

/* AI thinking pulse */
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
.ai-thinking { animation: pulse 1s ease-in-out infinite; }
</style>
</head>
<body>

<!-- Menu overlay -->
<div class="menu-overlay show" id="menuOverlay">
  <div class="menu-card">
    <div class="menu-title">PARITY TWIST</div>
    <div class="menu-sub">STRATEGY GAME</div>
    <div class="diff-label">VARIANT</div>
    <select id="variantSelect" class="menu-select">
      <option value="classic">Classic</option>
      <option value="dual-master">Dual Master Keys</option>
      <option value="key-lock">Key Locking</option>
      <option value="draft-place">Draft + Place</option>
      <option value="best-of-5">Best of 5 Rows</option>
      <option value="hidden-master">Hidden Master Key</option>
    </select>
    <button class="btn menu-btn menu-btn-vs" onclick="startGame(false)">VS PLAYER</button>
    <button class="btn menu-btn menu-btn-ai" id="menuAIBtn" onclick="showDifficulty()">VS AI</button>
    <div class="difficulty-panel" id="difficultyPanel" style="display:none;">
      <div class="diff-label">SELECT DIFFICULTY</div>
      <button class="btn diff-btn" onclick="selectDifficulty('easy')">EASY</button>
      <button class="btn diff-btn" onclick="selectDifficulty('medium')">MEDIUM</button>
      <button class="btn diff-btn" onclick="selectDifficulty('hard')">HARD</button>
    </div>
    <div class="difficulty-panel" id="turnOrderPanel" style="display:none;">
      <div class="diff-label">WHO GOES FIRST?</div>
      <button class="btn diff-btn" onclick="startGame(true,'human')">YOU</button>
      <button class="btn diff-btn" onclick="startGame(true,'ai')">AI</button>
      <button class="btn diff-btn" onclick="startGame(true,'random')">RANDOM</button>
    </div>
  </div>
</div>

<h1>PARITY TWIST</h1>
<div class="subtitle" id="subtitleText">STRATEGY GAME</div>

<!-- Scoreboard (shown at end of game, replaces turn bar) -->
<div class="scoreboard" id="scoreboard">
  <div class="scoreboard-title" id="scoreboardTitle"></div>
  <div class="scoreboard-score" id="scoreboardScore"></div>
</div>

<div class="turn-bar p1-turn" id="turnBar">
  <span class="dot"></span>
  <span id="turnText">Player 1's Turn</span>
</div>

<div class="board-container" id="boardContainer">
  <div class="col-headers">
    <span class="h-p1">P1</span>
    <span class="h-p2">P2</span>
    <span class="h-key">KEY</span>
  </div>

  <div class="board-with-indicators">
    <div class="grid" id="grid"></div>
    <div class="row-indicators" id="rowIndicators"></div>
  </div>

  <div class="master-key-area" id="masterKeyArea"></div>
</div>

<div class="parity-hint" id="parityHint">
  Tap a cell, then choose a number to place.
</div>

<!-- Endgame row-by-row breakdown (shown at end of game) -->
<div class="endgame-breakdown" id="endgameBreakdown"></div>

<div class="picker-label" id="pickerLabel">AVAILABLE NUMBERS</div>
<div class="number-picker" id="numberPicker"></div>

<div class="actions" id="gameActions">
  <button class="btn btn-primary" onclick="showMenu()">NEW GAME</button>
  <button class="btn btn-help" onclick="showHelp()">RULES</button>
</div>

<!-- Endgame action buttons (shown at end of game) -->
<div class="endgame-actions" id="endgameActions">
  <button class="btn btn-primary" onclick="hideEndgame(); newGame();">PLAY AGAIN</button>
  <button class="btn btn-secondary" onclick="hideEndgame(); showMenu();">MENU</button>
</div>

<!-- Help overlay -->
<div class="help-overlay" id="helpOverlay">
  <div class="help-content">
    <h2>How to Play</h2>
    <p><strong>Parity Twist</strong> is a 2-player strategy game. Compete to win 2 out of 3 rows!</p>

    <h3>Setup</h3>
    <p>The board has 3 columns: <span class="hl-p1">P1</span>, <span class="hl-p2">P2</span>, and <span class="hl-key">Key</span>, each with 3 rows. Below the Key column is the <span class="hl-mk">Master Key</span> cell.</p>

    <h3>Gameplay</h3>
    <p>Players take turns placing numbers <strong>1 to 10</strong> in any empty cell (in any column, or the Master Key). Each number can only be used once.</p>

    <h3>Winning a Row</h3>
    <p>After all 10 cells are filled, each row is scored:</p>
    <p>Compare the <span class="hl-key">Key</span> number's parity (odd/even) with the <span class="hl-mk">Master Key</span>'s parity:</p>
    <ul style="margin: 6px 0 6px 16px;">
      <li><strong>Same parity</strong> (both odd or both even) &rarr; the <em>lower</em> number between P1 and P2 wins the row</li>
      <li><strong>Different parity</strong> &rarr; the <em>higher</em> number wins the row</li>
    </ul>
    <p>Win <strong>2 out of 3</strong> rows to win the game!</p>

    <h3>Strategy</h3>
    <p>The Master Key affects ALL rows at once, making it a powerful move. Key column numbers determine the scoring rule per row. Plan ahead!</p>

    <button class="btn btn-primary help-close" onclick="hideHelp()">GOT IT</button>
  </div>
</div>

<script>
const VARIANTS = {
  classic: {
    id: 'classic', label: 'Classic', rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'dual-master': {
    id: 'dual-master', label: 'Dual Master Keys', rows: 3, numbers: 11,
    masters: [{ id: 'mkOdd', label: 'MASTER ODD' }, { id: 'mkEven', label: 'MASTER EVEN' }],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'key-lock': {
    id: 'key-lock', label: 'Key Locking', rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: true, draft: false, hiddenMaster: false
  },
  'draft-place': {
    id: 'draft-place', label: 'Draft + Place', rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: true, hiddenMaster: false
  },
  'best-of-5': {
    id: 'best-of-5', label: 'Best of 5 Rows', rows: 5, numbers: 16,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'hidden-master': {
    id: 'hidden-master', label: 'Hidden Master Key', rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'HIDDEN MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: true
  }
};

let currentVariant = VARIANTS.classic;
let board = {};
let usedNumbers = new Set();
let selectedCell = null;
let currentPlayer = 1;
let turnCount = 0;
let gameOver = false;
let numberPlacements = {};
let rowLocks = [];

// Draft mode state
let playerHands = { 1: [], 2: [] };
let marketNumbers = [];
let draftedThisTurn = false;

// AI state
let vsAI = false;
let aiDifficulty = 'medium';
let aiPlayer = 2;
let aiThinking = false;
let selectedDiff = 'medium';

function getBoardCells() {
  const cells = [];
  for (let r = 0; r < currentVariant.rows; r++) {
    for (let c = 0; c < 3; c++) cells.push(`r${r}c${c}`);
  }
  return cells;
}

function getAllCells() {
  return [...getBoardCells(), ...currentVariant.masters.map(m => m.id)];
}

function getRemainingNumbers() {
  const nums = [];
  for (let n = 1; n <= currentVariant.numbers; n++) if (!usedNumbers.has(n)) nums.push(n);
  return nums;
}

function randPick(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function init() {
  buildGrid();
  buildMasterKeyArea();
  buildPicker();
  updateTurnBar();
  updateParityHint();
}

function buildGrid() {
  const grid = document.getElementById('grid');
  grid.style.setProperty('--rows', String(currentVariant.rows));
  grid.innerHTML = '';

  for (let r = 0; r < currentVariant.rows; r++) {
    for (let c = 0; c < 3; c++) {
      const cell = document.createElement('div');
      cell.className = `cell col-${c}`;
      cell.id = `r${r}c${c}`;
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.onclick = () => selectCell(`r${r}c${c}`);
      grid.appendChild(cell);
    }
  }

  const indicators = document.getElementById('rowIndicators');
  indicators.innerHTML = '';
  for (let r = 0; r < currentVariant.rows; r++) {
    const ind = document.createElement('div');
    ind.className = 'row-ind-item';
    ind.id = `rowInd${r}`;
    indicators.appendChild(ind);
  }
}

function buildMasterKeyArea() {
  const area = document.getElementById('masterKeyArea');
  area.innerHTML = '';

  const slots = document.createElement('div');
  slots.className = 'master-key-slots';

  for (const mk of currentVariant.masters) {
    const slot = document.createElement('div');
    slot.className = 'master-key-slot';

    const label = document.createElement('div');
    label.className = 'master-key-label';
    label.textContent = mk.label;

    const cell = document.createElement('div');
    cell.className = 'master-key-cell';
    cell.id = mk.id;
    cell.onclick = () => selectCell(mk.id);

    slot.appendChild(label);
    slot.appendChild(cell);
    slots.appendChild(slot);
  }

  area.appendChild(slots);
}

function buildPicker() {
  const picker = document.getElementById('numberPicker');
  picker.innerHTML = '';

  if (currentVariant.draft) {
    renderDraftPicker();
    return;
  }

  for (let n = 1; n <= currentVariant.numbers; n++) {
    const btn = document.createElement('div');
    btn.className = 'num-btn';
    btn.id = `num-${n}`;
    btn.textContent = n;
    btn.onclick = () => placeNumber(n);
    picker.appendChild(btn);
  }
}

function renderDraftPicker() {
  const picker = document.getElementById('numberPicker');
  picker.innerHTML = '';

  if (!draftedThisTurn) {
    document.getElementById('pickerLabel').textContent = `DRAFT FROM MARKET (${marketNumbers.join(', ')})`;
    for (const n of marketNumbers) {
      const btn = document.createElement('div');
      btn.className = 'num-btn';
      btn.textContent = n;
      btn.onclick = () => draftNumber(n);
      picker.appendChild(btn);
    }
    return;
  }

  document.getElementById('pickerLabel').textContent = `PLACE FROM HAND (P${currentPlayer}: ${playerHands[currentPlayer].join(', ')})`;
  for (const n of playerHands[currentPlayer]) {
    const btn = document.createElement('div');
    btn.className = 'num-btn';
    btn.textContent = n;
    btn.onclick = () => placeNumber(n);
    picker.appendChild(btn);
  }
}

function isMasterCell(id) {
  return currentVariant.masters.some(m => m.id === id);
}

function getCellEl(id) {
  return document.getElementById(id);
}

function isCellLocked(id) {
  if (!currentVariant.keyLock) return false;
  if (!id.startsWith('r')) return false;
  const row = parseInt(id[1], 10);
  const col = parseInt(id[3], 10);
  if (col === 2) return false;
  return rowLocks[row] > 0;
}

function selectCell(id) {
  if (gameOver || aiThinking) return;
  if (board[id] !== undefined) return;
  if (isCellLocked(id)) {
    document.getElementById('parityHint').textContent = 'That row is temporarily locked.';
    return;
  }

  document.querySelectorAll('.cell.selected, .master-key-cell.selected').forEach(el => el.classList.remove('selected'));
  selectedCell = id;
  const el = getCellEl(id);
  if (el) el.classList.add('selected');
  updateParityHint();
}

function draftNumber(n) {
  if (!currentVariant.draft || gameOver || aiThinking) return;
  if (draftedThisTurn) return;
  if (!marketNumbers.includes(n)) return;

  marketNumbers = marketNumbers.filter(x => x !== n);
  playerHands[currentPlayer].push(n);
  draftedThisTurn = true;
  refillMarket();
  renderDraftPicker();
  updateParityHint();
}

function placeNumber(n) {
  if (gameOver || aiThinking) return;

  if (currentVariant.draft) {
    if (!draftedThisTurn) {
      document.getElementById('parityHint').textContent = 'Draft from market first.';
      return;
    }
    if (!playerHands[currentPlayer].includes(n)) return;
  } else {
    if (usedNumbers.has(n)) return;
  }

  if (selectedCell === null) {
    document.getElementById('parityHint').textContent = 'Tap a cell first!';
    return;
  }

  doPlaceNumber(selectedCell, n);
}

function doPlaceNumber(cellId, n) {
  board[cellId] = n;
  usedNumbers.add(n);
  numberPlacements[n] = { cell: cellId, player: currentPlayer };

  if (currentVariant.draft) {
    const hand = playerHands[currentPlayer];
    const idx = hand.indexOf(n);
    if (idx >= 0) hand.splice(idx, 1);
  }

  const el = getCellEl(cellId);
  if (el) {
    const hiddenMk = currentVariant.hiddenMaster && cellId === 'mk' && !gameOver;
    el.textContent = hiddenMk ? '?' : n;
    el.classList.remove('selected');
    el.classList.add('filled', 'cell-pop');
  }

  if (!currentVariant.draft) {
    const numBtn = document.getElementById(`num-${n}`);
    if (numBtn) {
      numBtn.classList.add('used');
      if (isMasterCell(cellId)) numBtn.classList.add('mk-placed');
      else {
        const col = parseInt(cellId[3], 10);
        if (col === 0) numBtn.classList.add('p1-placed');
        else if (col === 1) numBtn.classList.add('p2-placed');
        else numBtn.classList.add('key-placed');
      }
    }
  }

  if (currentVariant.keyLock && cellId.startsWith('r') && parseInt(cellId[3], 10) === 2) {
    const row = parseInt(cellId[1], 10);
    rowLocks[row] = 2;
  }

  selectedCell = null;
  turnCount++;

  if (turnCount >= getAllCells().length) {
    gameOver = true;
    setTimeout(resolveGame, 350);
  } else {
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    draftedThisTurn = false;
    decrementLocks();
    refreshLockedCells();
    updateTurnBar();

    if (currentVariant.draft) renderDraftPicker();

    if (vsAI && currentPlayer === aiPlayer && !gameOver) triggerAIMove();
  }

  updateParityHint();
}

function decrementLocks() {
  if (!currentVariant.keyLock) return;
  rowLocks = rowLocks.map(v => Math.max(0, v - 1));
}

function refreshLockedCells() {
  if (!currentVariant.keyLock) return;
  for (let r = 0; r < currentVariant.rows; r++) {
    for (let c = 0; c < 2; c++) {
      const el = document.getElementById(`r${r}c${c}`);
      if (!el) continue;
      if (rowLocks[r] > 0 && board[`r${r}c${c}`] === undefined) el.classList.add('locked');
      else el.classList.remove('locked');
    }
  }
}

function triggerAIMove() {
  aiThinking = true;
  updateTurnBar();

  setTimeout(() => {
    aiThinking = false;

    if (currentVariant.draft) {
      const d = randPick(marketNumbers);
      draftNumber(d);
      const cells = getLegalEmptyCells();
      const hand = playerHands[currentPlayer];
      if (cells.length && hand.length) doPlaceNumber(randPick(cells), randPick(hand));
      return;
    }

    const move = getAIMove();
    doPlaceNumber(move.cell, move.num);
  }, 350);
}

function getLegalEmptyCells() {
  return getAllCells().filter(c => board[c] === undefined && !isCellLocked(c));
}

function getAIMove() {
  if (currentVariant.id !== 'classic') return getRandomMove();

  if (aiDifficulty === 'easy') return getRandomMove();
  if (aiDifficulty === 'medium') return getBestMove(2);
  const movesLeft = getAllCells().filter(c => board[c] === undefined).length;
  const depth = movesLeft <= 6 ? movesLeft : 3;
  return getBestMove(depth);
}

function getRandomMove() {
  const emptyCells = getLegalEmptyCells();
  const availNums = getRemainingNumbers();
  return { cell: randPick(emptyCells), num: randPick(availNums) };
}

function getBestMove(maxDepth) {
  const emptyCells = getLegalEmptyCells();
  const availNums = getRemainingNumbers();
  const aiMaximizes = (aiPlayer === 2);
  let bestScore = aiMaximizes ? -Infinity : Infinity;
  let bestMove = null;

  for (const cell of emptyCells) {
    for (const num of availNums) {
      board[cell] = num;
      usedNumbers.add(num);
      const score = minimax(maxDepth - 1, !aiMaximizes, -Infinity, Infinity);
      board[cell] = undefined;
      usedNumbers.delete(num);

      if (aiMaximizes ? score > bestScore : score < bestScore) {
        bestScore = score;
        bestMove = { cell, num };
      }
    }
  }

  return bestMove || getRandomMove();
}

function minimax(depth, isMaximizing, alpha, beta) {
  const movesLeft = getAllCells().filter(c => board[c] === undefined).length;
  if (movesLeft === 0) return evaluateTerminalClassic();
  if (depth === 0) return evaluateHeuristicClassic();

  const emptyCells = getLegalEmptyCells();
  const availNums = getRemainingNumbers();

  if (isMaximizing) {
    let best = -Infinity;
    for (const cell of emptyCells) {
      for (const num of availNums) {
        board[cell] = num;
        usedNumbers.add(num);
        const score = minimax(depth - 1, false, alpha, beta);
        board[cell] = undefined;
        usedNumbers.delete(num);
        best = Math.max(best, score);
        alpha = Math.max(alpha, best);
        if (beta <= alpha) return best;
      }
    }
    return best;
  }

  let best = Infinity;
  for (const cell of emptyCells) {
    for (const num of availNums) {
      board[cell] = num;
      usedNumbers.add(num);
      const score = minimax(depth - 1, true, alpha, beta);
      board[cell] = undefined;
      usedNumbers.delete(num);
      best = Math.min(best, score);
      beta = Math.min(beta, best);
      if (beta <= alpha) return best;
    }
  }
  return best;
}

function evaluateTerminalClassic() {
  const mk = board['mk'];
  const mkEven = mk % 2 === 0;
  let p2Rows = 0;
  for (let r = 0; r < 3; r++) {
    const p1 = board[`r${r}c0`];
    const p2 = board[`r${r}c1`];
    const key = board[`r${r}c2`];
    const match = mkEven === (key % 2 === 0);
    const winner = match ? (p1 < p2 ? 1 : 2) : (p1 > p2 ? 1 : 2);
    p2Rows += winner === 2 ? 1 : -1;
  }
  return p2Rows;
}

function evaluateHeuristicClassic() {
  const mk = board['mk'];
  let score = 0;

  for (let r = 0; r < 3; r++) {
    const p1 = board[`r${r}c0`];
    const p2 = board[`r${r}c1`];
    const key = board[`r${r}c2`];

    if (p1 != null && p2 != null && key != null && mk != null) {
      const match = (mk % 2 === 0) === (key % 2 === 0);
      const winner = match ? (p1 < p2 ? 1 : 2) : (p1 > p2 ? 1 : 2);
      score += winner === 2 ? 1 : -1;
    } else if (p1 != null && p2 != null) {
      score += (p2 > p1 ? 0.12 : -0.12);
    } else if (p1 != null || p2 != null) {
      const val = p1 != null ? p1 : p2;
      const isP2 = p2 != null;
      const edge = (val >= 7 || val <= 3) ? 0.06 : 0;
      score += isP2 ? edge : -edge;
    }
  }

  if (mk != null) score += 0.03;
  return score;
}

function getRowRule(r) {
  const keyVal = board[`r${r}c2`];
  if (currentVariant.id === 'dual-master') {
    const mkId = keyVal % 2 === 1 ? 'mkOdd' : 'mkEven';
    const mkVal = board[mkId];
    const parityMatch = (keyVal % 2) === (mkVal % 2);
    return { mkVal, mkLabel: mkId === 'mkOdd' ? 'MO' : 'ME', parityMatch };
  }

  const mkVal = board['mk'];
  const parityMatch = (keyVal % 2) === (mkVal % 2);
  return { mkVal, mkLabel: 'MK', parityMatch };
}

function resolveGame() {
  if (currentVariant.hiddenMaster) {
    const mkEl = document.getElementById('mk');
    if (mkEl) mkEl.textContent = board['mk'];
  }

  let p1Wins = 0, p2Wins = 0;
  const rowResults = [];

  for (let r = 0; r < currentVariant.rows; r++) {
    const p1Val = board[`r${r}c0`];
    const p2Val = board[`r${r}c1`];
    const keyVal = board[`r${r}c2`];
    const rr = getRowRule(r);

    const winner = rr.parityMatch ? (p1Val < p2Val ? 1 : 2) : (p1Val > p2Val ? 1 : 2);
    if (winner === 1) p1Wins++; else p2Wins++;

    rowResults.push({
      row: r, p1Val, p2Val, keyVal,
      mk: rr.mkVal, mkLabel: rr.mkLabel,
      parityMatch: rr.parityMatch,
      winner,
      rule: rr.parityMatch ? 'lower wins' : 'higher wins'
    });

    const p1Cell = document.getElementById(`r${r}c0`);
    const p2Cell = document.getElementById(`r${r}c1`);
    if (winner === 1) {
      p1Cell.classList.add('row-win');
      p2Cell.classList.add('row-lose');
    } else {
      p2Cell.classList.add('row-win');
      p1Cell.classList.add('row-lose');
    }

    const ind = document.getElementById(`rowInd${r}`);
    if (ind) {
      ind.textContent = vsAI ? (winner === aiPlayer ? 'AI' : 'YOU') : `P${winner}`;
      ind.className = `row-ind-item show ${winner === 1 ? 'p1w' : 'p2w'}`;
    }
  }

  showEndgame(p1Wins, p2Wins, rowResults);
}

function showEndgame(p1Wins, p2Wins, rowResults) {
  const needed = Math.floor(currentVariant.rows / 2) + 1;
  const overallWinner = p1Wins >= needed ? 1 : 2;
  const winColor = overallWinner === 1 ? 'var(--p1)' : 'var(--p2)';

  const title = document.getElementById('scoreboardTitle');
  const scoreLine = document.getElementById('scoreboardScore');

  if (vsAI) title.textContent = overallWinner === aiPlayer ? 'AI WINS' : 'YOU WIN!';
  else title.textContent = `PLAYER ${overallWinner} WINS!`;
  title.style.color = winColor;

  const p1Label = vsAI ? (aiPlayer === 1 ? 'AI' : 'You') : 'P1';
  const p2Label = vsAI ? (aiPlayer === 2 ? 'AI' : 'You') : 'P2';
  scoreLine.textContent = `${p1Label} ${p1Wins} — ${p2Label} ${p2Wins}`;

  const breakdown = document.getElementById('endgameBreakdown');
  let html = '';
  for (const rr of rowResults) {
    const keyParity = rr.keyVal % 2 === 0 ? 'even' : 'odd';
    const mkParity = rr.mk % 2 === 0 ? 'even' : 'odd';
    const symbol = rr.parityMatch ? '=' : '≠';
    const rwLabel = vsAI ? (rr.winner === aiPlayer ? 'AI' : 'YOU') : `P${rr.winner}`;

    html += `<div class="breakdown-row">
      <span class="breakdown-label">Row ${rr.row + 1}</span>
      <span class="breakdown-rule">Key ${rr.keyVal}(${keyParity}) ${symbol} ${rr.mkLabel} ${rr.mk}(${mkParity}) → ${rr.rule}</span>
      <span class="breakdown-winner ${rr.winner === 1 ? 'bw-p1' : 'bw-p2'}">${rwLabel}</span>
    </div>`;
  }
  breakdown.innerHTML = html;

  document.getElementById('turnBar').style.display = 'none';
  document.getElementById('scoreboard').classList.add('show');
  document.getElementById('boardContainer').classList.add('endgame');
  document.getElementById('parityHint').style.display = 'none';
  document.getElementById('pickerLabel').style.display = 'none';
  document.getElementById('numberPicker').style.display = 'none';
  document.getElementById('gameActions').style.display = 'none';
  breakdown.classList.add('show');
  document.getElementById('endgameActions').classList.add('show');
}

function hideEndgame() {
  document.getElementById('turnBar').style.display = '';
  document.getElementById('scoreboard').classList.remove('show');
  document.getElementById('boardContainer').classList.remove('endgame');
  document.getElementById('parityHint').style.display = '';
  document.getElementById('pickerLabel').style.display = '';
  document.getElementById('numberPicker').style.display = '';
  document.getElementById('gameActions').style.display = '';
  document.getElementById('endgameBreakdown').classList.remove('show');
  document.getElementById('endgameActions').classList.remove('show');
}

function updateTurnBar() {
  const bar = document.getElementById('turnBar');
  const text = document.getElementById('turnText');
  bar.className = `turn-bar p${currentPlayer}-turn`;

  if (aiThinking) {
    text.textContent = 'AI is thinking...';
    bar.classList.add('ai-thinking');
  } else if (vsAI) {
    text.textContent = currentPlayer === aiPlayer ? "AI's Turn" : 'Your Turn';
    bar.classList.remove('ai-thinking');
  } else {
    text.textContent = `Player ${currentPlayer}'s Turn`;
    bar.classList.remove('ai-thinking');
  }
}

function updateParityHint() {
  const hint = document.getElementById('parityHint');
  if (gameOver) {
    hint.style.display = 'none';
    return;
  }

  if (currentVariant.draft) {
    if (!draftedThisTurn) {
      hint.textContent = `Draft phase: pick one from market (${marketNumbers.join(', ')}), then place from your hand.`;
      return;
    }
    hint.textContent = `Place phase: choose a cell, then place from hand (${playerHands[currentPlayer].join(', ')}).`;
    return;
  }

  if (currentVariant.id === 'dual-master') {
    const mo = board['mkOdd'];
    const me = board['mkEven'];
    if (mo != null || me != null) {
      hint.textContent = `Odd keys use MASTER ODD (${mo ?? '?'}). Even keys use MASTER EVEN (${me ?? '?'}).`;
      return;
    }
  }

  if (currentVariant.hiddenMaster && board['mk'] != null) {
    hint.textContent = 'Master Key is hidden until the end. Plan for both parity outcomes.';
    return;
  }

  if (board['mk'] !== undefined) {
    const mkVal = board['mk'];
    const mkParity = mkVal % 2 === 0 ? 'even' : 'odd';
    hint.innerHTML = `Master Key is <span class="${mkParity === 'even' ? 'even' : 'odd'}">${mkVal} (${mkParity})</span>. ` +
      `Key matches → <span class="low">lower wins</span>. Key differs → <span class="high">higher wins</span>.`;
    return;
  }

  if (selectedCell) {
    if (isMasterCell(selectedCell)) hint.textContent = 'Placing in a Master Key cell.';
    else {
      const col = parseInt(selectedCell[3], 10);
      const colName = ['P1', 'P2', 'Key'][col];
      hint.textContent = `Placing in ${colName} column. Choose a number.`;
    }
    return;
  }

  if (currentVariant.keyLock) {
    hint.textContent = 'Tap a cell, then choose a number. Key placements lock that row for one opponent turn.';
  } else {
    hint.textContent = 'Tap a cell, then choose a number to place.';
  }
}

function showHelp() {
  document.getElementById('helpOverlay').classList.add('show');
}

function hideHelp() {
  document.getElementById('helpOverlay').classList.remove('show');
}

function showMenu() {
  hideEndgame();
  document.getElementById('difficultyPanel').style.display = 'none';
  document.getElementById('turnOrderPanel').style.display = 'none';
  document.getElementById('menuAIBtn').style.display = '';
  document.getElementById('menuOverlay').classList.add('show');
}

function showDifficulty() {
  document.getElementById('difficultyPanel').style.display = 'flex';
  document.getElementById('menuAIBtn').style.display = 'none';
}

function selectDifficulty(diff) {
  selectedDiff = diff;
  document.getElementById('difficultyPanel').style.display = 'none';
  document.getElementById('turnOrderPanel').style.display = 'flex';
}

function startGame(ai, turnOrder) {
  const selectedVariantId = document.getElementById('variantSelect').value;
  currentVariant = VARIANTS[selectedVariantId] || VARIANTS.classic;

  vsAI = ai;
  if (vsAI) {
    aiDifficulty = selectedDiff;
    if (turnOrder === 'ai') aiPlayer = 1;
    else if (turnOrder === 'random') aiPlayer = Math.random() < 0.5 ? 1 : 2;
    else aiPlayer = 2;
  }

  document.getElementById('menuOverlay').classList.remove('show');
  const aiNote = currentVariant.id === 'classic' ? aiDifficulty.toUpperCase() : 'RANDOM';
  document.getElementById('subtitleText').textContent = vsAI
    ? `VS AI (${aiNote}) • ${currentVariant.label.toUpperCase()}`
    : `${currentVariant.label.toUpperCase()} • 2-PLAYER`;

  newGame();
}

function refillMarket() {
  if (!currentVariant.draft) return;
  const remaining = getRemainingNumbers().filter(n => !marketNumbers.includes(n) && !playerHands[1].includes(n) && !playerHands[2].includes(n));
  while (marketNumbers.length < 3 && remaining.length) {
    const pick = randPick(remaining);
    marketNumbers.push(pick);
    remaining.splice(remaining.indexOf(pick), 1);
  }
}

function newGame() {
  board = {};
  usedNumbers.clear();
  selectedCell = null;
  currentPlayer = 1;
  turnCount = 0;
  gameOver = false;
  numberPlacements = {};
  aiThinking = false;
  rowLocks = Array(currentVariant.rows).fill(0);

  playerHands = { 1: [], 2: [] };
  marketNumbers = [];
  draftedThisTurn = false;

  hideEndgame();
  buildGrid();
  buildMasterKeyArea();

  if (currentVariant.draft) {
    refillMarket();
    buildPicker();
  } else {
    buildPicker();
    document.getElementById('pickerLabel').textContent = 'AVAILABLE NUMBERS';
  }

  const headers = document.querySelectorAll('.col-headers span');
  if (vsAI) {
    headers[0].textContent = aiPlayer === 1 ? 'AI' : 'YOU';
    headers[1].textContent = aiPlayer === 2 ? 'AI' : 'YOU';
  } else {
    headers[0].textContent = 'P1';
    headers[1].textContent = 'P2';
  }

  updateTurnBar();
  updateParityHint();

  if (vsAI && currentPlayer === aiPlayer) triggerAIMove();
}

init();
</script>
</body>
</html>
