<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Parity Twist</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

:root {
  --bg: #0f0e17;
  --surface: #1a1a2e;
  --surface2: #16213e;
  --p1: #4ecca3;
  --p2: #e94560;
  --key: #0f3460;
  --key-light: #3a86ff;
  --text: #eaeaea;
  --text-dim: #8892a0;
  --gold: #ffd700;
  --win-glow: rgba(78, 204, 163, 0.25);
  --lose-glow: rgba(233, 69, 96, 0.25);
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow-x: hidden;
  padding: 12px;
  user-select: none;
}

h1 {
  font-size: 1.6rem;
  font-weight: 700;
  letter-spacing: 2px;
  margin: 8px 0 4px;
  background: linear-gradient(135deg, var(--p1), var(--key-light), var(--p2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.subtitle {
  font-size: 0.75rem;
  color: var(--text-dim);
  margin-bottom: 12px;
}

/* Turn indicator */
.turn-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 8px 20px;
  border-radius: 20px;
  background: var(--surface);
  margin-bottom: 14px;
  font-size: 0.95rem;
  font-weight: 600;
  transition: all 0.3s;
}
.turn-bar.p1-turn { border: 2px solid var(--p1); }
.turn-bar.p2-turn { border: 2px solid var(--p2); }
.turn-bar .dot {
  width: 10px; height: 10px;
  border-radius: 50%;
  transition: background 0.3s;
}
.turn-bar.p1-turn .dot { background: var(--p1); }
.turn-bar.p2-turn .dot { background: var(--p2); }

/* Scoreboard (shown at end of game) */
.scoreboard {
  display: none;
  flex-direction: column;
  align-items: center;
  margin-bottom: 10px;
  animation: fadeIn 0.4s;
}
.scoreboard.show { display: flex; }
.scoreboard-title {
  font-size: 2rem;
  font-weight: 800;
  letter-spacing: 2px;
}
.scoreboard-score {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--text-dim);
  margin-top: 2px;
}

/* Game board */
.board-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0;
  transition: transform 0.4s, margin-bottom 0.4s;
}
.board-container.endgame {
  transform: scale(0.82);
  transform-origin: top center;
  margin-bottom: -55px;
}

.col-headers {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  width: 270px;
  margin-bottom: 4px;
}
.col-headers span {
  text-align: center;
  font-size: 0.8rem;
  font-weight: 700;
  letter-spacing: 1px;
}
.col-headers .h-p1 { color: var(--p1); }
.col-headers .h-p2 { color: var(--p2); }
.col-headers .h-key { color: var(--key-light); }

.grid {
  display: grid;
  grid-template-columns: repeat(3, 90px);
  grid-template-rows: repeat(var(--rows, 3), 72px);
  gap: 0;
  border: 2px solid #2a2a4a;
  border-radius: 10px;
  overflow: hidden;
  background: #2a2a4a;
}

.cell {
  background: var(--surface);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.6rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  border: 1px solid #2a2a4a;
  position: relative;
}
.cell:active { transform: scale(0.95); }
.cell.selected {
  background: var(--surface2);
  box-shadow: inset 0 0 20px rgba(58, 134, 255, 0.3);
}
.cell.filled { cursor: default; }
.cell.filled:active { transform: none; }
.cell.locked {
  opacity: 0.55;
  box-shadow: inset 0 0 0 2px rgba(255, 215, 0, 0.35);
}
.cell.last-move {
  outline: 1px solid rgba(255, 215, 0, 0.55);
  outline-offset: -1px;
}

.cell.col-0 { color: var(--p1); }
.cell.col-1 { color: var(--p2); }
.cell.col-2 { color: var(--key-light); }

/* Row result indicators */
.cell.row-win { box-shadow: inset 0 0 20px var(--win-glow); }
.cell.row-lose { box-shadow: inset 0 0 20px var(--lose-glow); }

/* Row labels */
.row-labels {
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  margin-left: 6px;
}

/* Master Key */
.master-key-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 6px;
}
.master-key-slots {
  display: flex;
  gap: 8px;
  align-items: center;
}
.master-key-slot {
  display: flex;
  flex-direction: column;
  align-items: center;
}
.master-key-label {
  font-size: 0.7rem;
  color: var(--text-dim);
  letter-spacing: 1px;
  margin-bottom: 3px;
}
.master-key-cell {
  width: 90px;
  height: 72px;
  background: var(--surface);
  border: 2px solid var(--key);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.6rem;
  font-weight: 700;
  color: var(--gold);
  cursor: pointer;
  transition: all 0.2s;
}
.master-key-cell:active { transform: scale(0.95); }
.master-key-cell.selected {
  background: var(--surface2);
  box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.2);
  border-color: var(--gold);
}
.master-key-cell.filled { cursor: default; }
.master-key-cell.filled:active { transform: none; }
.master-key-cell.last-move {
  box-shadow: inset 0 0 0 1px rgba(255, 215, 0, 0.55), 0 0 6px rgba(255, 215, 0, 0.2);
}

/* Number picker */
.picker-label {
  font-size: 0.75rem;
  color: var(--text-dim);
  margin: 14px 0 6px;
  letter-spacing: 1px;
}
.number-picker {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  width: 280px;
}
.num-btn {
  width: 48px;
  height: 44px;
  border: 2px solid #2a2a4a;
  border-radius: 10px;
  background: var(--surface);
  color: var(--text);
  font-size: 1.1rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.num-btn:active { transform: scale(0.92); }
.num-btn.selected {
  border-color: var(--gold);
  box-shadow: 0 0 10px rgba(255, 215, 0, 0.35);
}
.num-btn.used {
  opacity: 0.2;
  cursor: default;
  text-decoration: line-through;
}
.num-btn.used:active { transform: none; }
.num-btn.p1-placed { border-color: var(--p1); color: var(--p1); opacity: 0.4; }
.num-btn.p2-placed { border-color: var(--p2); color: var(--p2); opacity: 0.4; }
.num-btn.key-placed { border-color: var(--key-light); color: var(--key-light); opacity: 0.4; }
.num-btn.mk-placed { border-color: var(--gold); color: var(--gold); opacity: 0.4; }

/* Action buttons */
.actions {
  display: flex;
  gap: 10px;
  margin-top: 14px;
}
.btn {
  padding: 10px 22px;
  border: none;
  border-radius: 10px;
  font-size: 0.9rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  letter-spacing: 1px;
}
.btn:active { transform: scale(0.95); }
.btn-primary {
  background: linear-gradient(135deg, var(--p1), var(--key-light));
  color: var(--bg);
}
.btn-secondary {
  background: var(--surface);
  color: var(--text);
  border: 2px solid #2a2a4a;
}
.btn-help {
  background: var(--surface);
  color: var(--text-dim);
  border: 2px solid #2a2a4a;
  font-size: 0.8rem;
  padding: 8px 14px;
}

/* Endgame breakdown */
.endgame-breakdown {
  display: none;
  flex-direction: column;
  gap: 5px;
  width: 310px;
  margin-top: 8px;
  animation: fadeIn 0.4s;
}
.endgame-breakdown.show { display: flex; }
.breakdown-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 7px 10px;
  border-radius: 8px;
  background: var(--surface);
  font-size: 0.78rem;
}
.breakdown-label {
  font-weight: 700;
  min-width: 44px;
}
.breakdown-rule {
  flex: 1;
  color: var(--text-dim);
  font-size: 0.7rem;
}
.breakdown-winner {
  font-size: 0.68rem;
  font-weight: 700;
  padding: 2px 8px;
  border-radius: 10px;
}
.breakdown-winner.bw-p1 { background: var(--p1); color: var(--bg); }
.breakdown-winner.bw-p2 { background: var(--p2); color: white; }

/* Endgame actions */
.endgame-actions {
  display: none;
  gap: 10px;
  margin-top: 14px;
  animation: fadeIn 0.4s;
}
.endgame-actions.show { display: flex; }

@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

/* Help modal */
.help-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 14, 23, 0.95);
  z-index: 200;
  overflow-y: auto;
  padding: 20px;
  animation: fadeIn 0.3s;
}
.help-overlay.show { display: block; }
.help-content {
  background: var(--surface);
  border-radius: 16px;
  padding: 24px;
  max-width: 360px;
  margin: 0 auto;
  font-size: 0.82rem;
  line-height: 1.6;
  color: var(--text-dim);
}
.help-content h2 {
  color: var(--text);
  font-size: 1.2rem;
  margin-bottom: 12px;
}
.help-content h3 {
  color: var(--text);
  font-size: 0.95rem;
  margin: 14px 0 6px;
}
.help-content .hl-p1 { color: var(--p1); font-weight: 700; }
.help-content .hl-p2 { color: var(--p2); font-weight: 700; }
.help-content .hl-key { color: var(--key-light); font-weight: 700; }
.help-content .hl-mk { color: var(--gold); font-weight: 700; }
.help-close {
  margin-top: 16px;
  width: 100%;
}

/* Animations */
@keyframes pop {
  0% { transform: scale(0.5); opacity: 0; }
  60% { transform: scale(1.15); }
  100% { transform: scale(1); opacity: 1; }
}
.cell-pop { animation: pop 0.3s ease-out; }

/* Row result arrows / indicators on board */
.row-indicator {
  position: absolute;
  right: -28px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 1.2rem;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Board wrapper with row indicators */
.board-with-indicators {
  display: flex;
  align-items: flex-start;
  gap: 0;
}

.row-indicators {
  display: flex;
  flex-direction: column;
  margin-left: 8px;
}
.row-ind-item {
  height: 72px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.65rem;
  font-weight: 700;
  width: 40px;
  border-radius: 6px;
  opacity: 0;
  transition: opacity 0.4s;
}
.row-ind-item.show { opacity: 1; }
.row-ind-item.p1w { color: var(--p1); background: rgba(78, 204, 163, 0.1); }
.row-ind-item.p2w { color: var(--p2); background: rgba(233, 69, 96, 0.1); }

/* Parity hint at bottom */
.parity-hint {
  margin-top: 10px;
  font-size: 0.72rem;
  color: var(--text-dim);
  text-align: center;
  min-height: 2.5em;
  padding: 4px 10px;
  border-radius: 8px;
  background: var(--surface);
  width: 290px;
  line-height: 1.4;
}
.parity-hint .even { color: var(--key-light); }
.parity-hint .odd { color: var(--p2); }
.parity-hint .low { color: var(--p1); }
.parity-hint .high { color: var(--gold); }

/* Menu overlay */
.menu-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg);
  z-index: 300;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.4s;
}
.menu-overlay.show { display: flex; }
.menu-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}
.menu-title {
  font-size: 2.2rem;
  font-weight: 700;
  letter-spacing: 3px;
  background: linear-gradient(135deg, var(--p1), var(--key-light), var(--p2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 0;
}
.menu-sub {
  font-size: 0.8rem;
  color: var(--text-dim);
  letter-spacing: 2px;
  margin-bottom: 20px;
}
.menu-btn {
  width: 200px;
  padding: 14px;
  font-size: 1rem;
  text-align: center;
  border: none;
}
.menu-btn-vs {
  background: linear-gradient(135deg, var(--p1), var(--key-light));
  color: var(--bg);
}
.menu-btn-ai {
  background: linear-gradient(135deg, var(--p2), #ff6b6b);
  color: white;
}
.difficulty-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  margin-top: 4px;
  animation: fadeIn 0.3s;
}
.diff-label {
  font-size: 0.75rem;
  color: var(--text-dim);
  letter-spacing: 1px;
}
.diff-btn {
  width: 180px;
  padding: 11px;
  font-size: 0.85rem;
  background: var(--surface);
  color: var(--text);
  border: 2px solid #2a2a4a;
  text-align: center;
}
.diff-btn:hover { border-color: var(--p2); }
.menu-btn-variant {
  background: var(--surface);
  color: var(--text);
  border: 2px solid #2a2a4a;
}
.variant-screen {
  width: min(92vw, 360px);
  max-height: 72vh;
  overflow-y: auto;
  background: var(--surface);
  border: 2px solid #2a2a4a;
  border-radius: 14px;
  padding: 10px;
  display: none;
  flex-direction: column;
  gap: 8px;
}
.variant-screen.show { display: flex; }
.variant-card {
  border: 2px solid #2a2a4a;
  border-radius: 10px;
  padding: 10px;
  background: var(--bg);
  text-align: left;
  cursor: pointer;
}
.variant-card.active {
  border-color: var(--key-light);
  box-shadow: inset 0 0 0 1px rgba(58, 134, 255, 0.4);
}
.variant-card-title {
  font-size: 0.92rem;
  font-weight: 700;
  color: var(--text);
}
.variant-card-desc {
  margin-top: 4px;
  font-size: 0.75rem;
  color: var(--text-dim);
  line-height: 1.35;
}
.variant-select-btn {
  margin-top: 8px;
  padding: 6px 0;
  width: 100%;
  border: none;
  border-radius: 6px;
  background: var(--key-light);
  color: #fff;
  font-size: 0.85rem;
  font-weight: 700;
  letter-spacing: 1px;
  cursor: pointer;
}

/* Variant display bar */
.variant-display {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-bottom: 10px;
}
.variant-display-name {
  font-size: 1.05rem;
  font-weight: 700;
  letter-spacing: 1.5px;
  color: var(--key-light);
  text-transform: uppercase;
}
.variant-change-btn {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  border: none;
  background: var(--gold);
  color: var(--bg);
  font-size: 0.85rem;
  font-weight: 800;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
  flex-shrink: 0;
}
.variant-change-btn:active { transform: scale(0.9); }

/* AI thinking pulse */
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
.ai-thinking { animation: pulse 1s ease-in-out infinite; }
</style>
</head>
<body>

<!-- Menu overlay -->
<div class="menu-overlay show" id="menuOverlay">
  <div class="menu-card">
    <div class="menu-title">PARITY TWIST</div>
    <div class="menu-sub">STRATEGY GAME</div>
    <button class="btn menu-btn menu-btn-variant" id="menuVariantBtn" onclick="showVariantChooser()">VARIANT: CLASSIC</button>
    <button class="btn menu-btn menu-btn-vs" id="menuVsBtn" onclick="startGame(false)">VS PLAYER</button>
    <button class="btn menu-btn menu-btn-ai" id="menuAIBtn" onclick="showDifficulty()">VS AI</button>
    <div class="difficulty-panel" id="difficultyPanel" style="display:none;">
      <div class="diff-label">SELECT DIFFICULTY</div>
      <button class="btn diff-btn" onclick="selectDifficulty('easy')">EASY</button>
      <button class="btn diff-btn" onclick="selectDifficulty('medium')">MEDIUM</button>
      <button class="btn diff-btn" onclick="selectDifficulty('hard')">HARD</button>
    </div>
    <div class="difficulty-panel" id="turnOrderPanel" style="display:none;">
      <div class="diff-label">WHO GOES FIRST?</div>
      <button class="btn diff-btn" onclick="startGame(true,'human')">YOU</button>
      <button class="btn diff-btn" onclick="startGame(true,'ai')">AI</button>
      <button class="btn diff-btn" onclick="startGame(true,'random')">RANDOM</button>
    </div>

    <div class="variant-screen" id="variantScreen">
      <button class="btn diff-btn" onclick="hideVariantChooser()">BACK</button>
      <div class="diff-label">CHOOSE A VARIANT</div>
      <div id="variantList"></div>
    </div>
  </div>
</div>

<h1>PARITY TWIST</h1>
<div class="subtitle" id="subtitleText">STRATEGY GAME</div>

<div class="variant-display" id="variantDisplay">
  <span class="variant-display-name" id="variantDisplayName">CLASSIC</span>
  <button class="variant-change-btn" onclick="goToVariantScreen()" title="Change variant">&#9998;</button>
</div>

<!-- Scoreboard (shown at end of game, replaces turn bar) -->
<div class="scoreboard" id="scoreboard">
  <div class="scoreboard-title" id="scoreboardTitle"></div>
  <div class="scoreboard-score" id="scoreboardScore"></div>
</div>

<div class="turn-bar p1-turn" id="turnBar">
  <span class="dot"></span>
  <span id="turnText">Player 1's Turn</span>
</div>

<div class="board-container" id="boardContainer">
  <div class="col-headers">
    <span class="h-p1">P1</span>
    <span class="h-p2">P2</span>
    <span class="h-key">KEY</span>
  </div>

  <div class="board-with-indicators">
    <div class="grid" id="grid"></div>
    <div class="row-indicators" id="rowIndicators"></div>
  </div>

  <div class="master-key-area" id="masterKeyArea"></div>
</div>

<div class="parity-hint" id="parityHint">
  Tap a cell, then choose a number to place.
</div>

<!-- Endgame row-by-row breakdown (shown at end of game) -->
<div class="endgame-breakdown" id="endgameBreakdown"></div>

<div class="picker-label" id="pickerLabel">AVAILABLE NUMBERS</div>
<div class="number-picker" id="numberPicker"></div>

<div class="actions" id="gameActions">
  <button class="btn btn-primary" onclick="showMenu()">NEW GAME</button>
  <button class="btn btn-help" onclick="showHelp()">RULES</button>
</div>

<!-- Endgame action buttons (shown at end of game) -->
<div class="endgame-actions" id="endgameActions">
  <button class="btn btn-primary" onclick="hideEndgame(); newGame();">PLAY AGAIN</button>
  <button class="btn btn-secondary" onclick="hideEndgame(); showMenu();">MENU</button>
</div>

<!-- Help overlay -->
<div class="help-overlay" id="helpOverlay">
  <div class="help-content">
    <h2 id="helpTitle">How to Play</h2>
    <div id="helpBody"></div>
    <button class="btn btn-primary help-close" onclick="hideHelp()">GOT IT</button>
  </div>
</div>

<script>
const VARIANTS = {
  classic: {
    id: 'classic', label: 'Classic',
    desc: 'Original 3-row game with one Master Key affecting every row.',
    rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'total-score': {
    id: 'total-score', label: 'Total Score',
    desc: 'Row winners score by value: add the winning number from each row; highest total wins.',
    rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'whiteacre': {
    id: 'whiteacre', label: 'Whiteacre',
    desc: 'Classic scoring with numbers 1-12; fill 10 cells and leave 2 unplayed.',
    rows: 3, numbers: 12,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'sandkuhler': {
    id: 'sandkuhler', label: 'Sandkühler',
    desc: 'Classic scoring, but Master Key cannot be last and must be placed by turn 6.',
    rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: false,
    masterDeadlineTurn: 6
  },
  'key-sum-9': {
    id: 'key-sum-9', label: 'Delfs',
    desc: '9-box mode: no master cell; parity uses the sum of the Key column.',
    rows: 3, numbers: 9,
    masters: [],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'key-lock': {
    id: 'key-lock', label: 'Key Locking',
    desc: 'Placing a Key locks that row’s P1/P2 cells for one opponent turn.',
    rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: true, draft: false, hiddenMaster: false
  },
  'dual-master': {
    id: 'dual-master', label: 'Dual Master Keys',
    desc: 'Odd-key rows use MASTER ODD, even-key rows use MASTER EVEN.',
    rows: 3, numbers: 11,
    masters: [{ id: 'mkOdd', label: 'MASTER ODD' }, { id: 'mkEven', label: 'MASTER EVEN' }],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'hodgkins': {
    id: 'hodgkins', label: 'Hodgkins',
    desc: 'Classic board scoring, plus row-closeness points: parity row wins are worth 2 each; closest-to-key in each row earns +1.',
    rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: false
  },
  'lanier': {
    id: 'lanier', label: 'Lanier',
    desc: 'Use number cards 0-9. Play from a hand, then draw back up to 3 after each turn.',
    rows: 3, numbers: 10, numberStart: 0,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: false, hiddenMaster: false,
    lanier: true
  },
  'draft-place': {
    id: 'draft-place', label: 'Draft + Place',
    desc: 'Each turn: draft a number from market, then place from your hand.',
    rows: 3, numbers: 10,
    masters: [{ id: 'mk', label: 'MASTER KEY' }],
    keyLock: false, draft: true, hiddenMaster: false
  },
};

let selectedVariantId = 'classic';
let currentVariant = VARIANTS.classic;
let board = {};
let usedNumbers = new Set();
let selectedCell = null;
let selectedNumber = null;
let currentPlayer = 1;
let turnCount = 0;
let gameOver = false;
let numberPlacements = {};
let rowLocks = [];

// Draft/Lanier hand state
let playerHands = { 1: [], 2: [] };
let marketNumbers = [];
let draftedThisTurn = false;
let lanierDeck = [];

// AI state
let vsAI = false;
let aiDifficulty = 'medium';
let aiPlayer = 2;
let aiThinking = false;
let selectedDiff = 'medium';

function getBoardCells() {
  const cells = [];
  for (let r = 0; r < currentVariant.rows; r++) {
    for (let c = 0; c < 3; c++) cells.push(`r${r}c${c}`);
  }
  return cells;
}

function getAllCells() {
  return [...getBoardCells(), ...currentVariant.masters.map(m => m.id)];
}

function getNumberRange() {
  const start = currentVariant.numberStart ?? 1;
  const end = start + currentVariant.numbers - 1;
  return { start, end };
}

function getRemainingNumbers() {
  const nums = [];
  const { start, end } = getNumberRange();
  for (let n = start; n <= end; n++) if (!usedNumbers.has(n)) nums.push(n);
  return nums;
}

function randPick(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function init() {
  buildGrid();
  buildMasterKeyArea();
  buildPicker();
  updateVariantButton();
  renderVariantChooser();
  renderHelpContent();
  updateTurnBar();
  updateParityHint();
}

function buildGrid() {
  const grid = document.getElementById('grid');
  grid.style.setProperty('--rows', String(currentVariant.rows));
  grid.innerHTML = '';

  for (let r = 0; r < currentVariant.rows; r++) {
    for (let c = 0; c < 3; c++) {
      const cell = document.createElement('div');
      cell.className = `cell col-${c}`;
      cell.id = `r${r}c${c}`;
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.onclick = () => selectCell(`r${r}c${c}`);
      grid.appendChild(cell);
    }
  }

  const indicators = document.getElementById('rowIndicators');
  indicators.innerHTML = '';
  for (let r = 0; r < currentVariant.rows; r++) {
    const ind = document.createElement('div');
    ind.className = 'row-ind-item';
    ind.id = `rowInd${r}`;
    indicators.appendChild(ind);
  }
}

function buildMasterKeyArea() {
  const area = document.getElementById('masterKeyArea');
  area.innerHTML = '';

  const slots = document.createElement('div');
  slots.className = 'master-key-slots';

  for (const mk of currentVariant.masters) {
    const slot = document.createElement('div');
    slot.className = 'master-key-slot';

    const label = document.createElement('div');
    label.className = 'master-key-label';
    label.textContent = mk.label;

    const cell = document.createElement('div');
    cell.className = 'master-key-cell';
    cell.id = mk.id;
    cell.onclick = () => selectCell(mk.id);

    slot.appendChild(label);
    slot.appendChild(cell);
    slots.appendChild(slot);
  }

  area.appendChild(slots);
}

function buildPicker() {
  const picker = document.getElementById('numberPicker');
  picker.innerHTML = '';

  if (currentVariant.draft) {
    renderDraftPicker();
    return;
  }

  if (currentVariant.lanier) {
    renderLanierPicker();
    return;
  }

  const { start, end } = getNumberRange();
  for (let n = start; n <= end; n++) {
    const btn = document.createElement('div');
    btn.className = 'num-btn';
    btn.id = `num-${n}`;
    btn.textContent = n;
    btn.onclick = () => placeNumber(n);
    picker.appendChild(btn);
  }
}

function renderDraftPicker() {
  const picker = document.getElementById('numberPicker');
  picker.innerHTML = '';

  if (!draftedThisTurn) {
    document.getElementById('pickerLabel').textContent = `DRAFT FROM MARKET (${marketNumbers.join(', ')})`;
    for (const n of marketNumbers) {
      const btn = document.createElement('div');
      btn.className = 'num-btn';
      btn.id = `num-${n}`;
      btn.textContent = n;
      btn.onclick = () => draftNumber(n);
      picker.appendChild(btn);
    }
    return;
  }

  document.getElementById('pickerLabel').textContent = `PLACE FROM HAND (P${currentPlayer}: ${playerHands[currentPlayer].join(', ')})`;
  for (const n of playerHands[currentPlayer]) {
    const btn = document.createElement('div');
    btn.className = `num-btn${selectedNumber === n ? ' selected' : ''}`;
    btn.id = `num-${n}`;
    btn.textContent = n;
    btn.onclick = () => placeNumber(n);
    picker.appendChild(btn);
  }
}

function renderLanierPicker() {
  const picker = document.getElementById('numberPicker');
  picker.innerHTML = '';

  document.getElementById('pickerLabel').textContent = `HAND (P${currentPlayer}: ${playerHands[currentPlayer].join(', ')})`;
  for (const n of playerHands[currentPlayer]) {
    const btn = document.createElement('div');
    btn.className = `num-btn${selectedNumber === n ? ' selected' : ''}`;
    btn.id = `num-${n}`;
    btn.textContent = n;
    btn.onclick = () => placeNumber(n);
    picker.appendChild(btn);
  }
}

function isMasterCell(id) {
  return currentVariant.masters.some(m => m.id === id);
}

function getCellEl(id) {
  return document.getElementById(id);
}

function refreshNumberSelectionUI() {
  document.querySelectorAll('.num-btn.selected').forEach(el => el.classList.remove('selected'));
  if (selectedNumber == null) return;
  const btn = document.getElementById(`num-${selectedNumber}`);
  if (btn) btn.classList.add('selected');
}

function trySubmitSelectedMove() {
  if (selectedCell == null || selectedNumber == null) return false;
  doPlaceNumber(selectedCell, selectedNumber);
  return true;
}

function isCellLocked(id) {
  if (!currentVariant.keyLock) return false;
  if (!id.startsWith('r')) return false;
  const row = parseInt(id[1], 10);
  const col = parseInt(id[3], 10);
  if (col === 2) return false;
  return rowLocks[row] > 0;
}

function isSandkuhlerMasterForced(simBoard, placedCount) {
  if (currentVariant.id !== 'sandkuhler') return false;
  if (simBoard['mk'] !== undefined) return false;
  const deadline = (currentVariant.masterDeadlineTurn ?? 6) - 1;
  return placedCount >= deadline;
}

function selectCell(id) {
  if (gameOver || aiThinking) return;
  if (board[id] !== undefined) return;
  if (isCellLocked(id)) {
    document.getElementById('parityHint').textContent = 'That row is temporarily locked.';
    return;
  }
  if (isSandkuhlerMasterForced(board, turnCount) && id !== 'mk') {
    document.getElementById('parityHint').textContent = 'Sandkühler rule: Master Key must be placed now.';
    return;
  }

  const prevCell = selectedCell;
  document.querySelectorAll('.cell.selected, .master-key-cell.selected').forEach(el => el.classList.remove('selected'));

  if (prevCell === id) {
    selectedCell = null;
    updateParityHint();
    return;
  }

  selectedCell = id;
  const el = getCellEl(id);
  if (el) el.classList.add('selected');

  if (trySubmitSelectedMove()) return;
  updateParityHint();
}

function draftNumber(n) {
  if (!currentVariant.draft || gameOver || aiThinking) return;
  if (draftedThisTurn) return;
  if (!marketNumbers.includes(n)) return;

  marketNumbers = marketNumbers.filter(x => x !== n);
  playerHands[currentPlayer].push(n);
  draftedThisTurn = true;
  refillMarket();
  renderDraftPicker();
  updateParityHint();
}

function placeNumber(n) {
  if (gameOver || aiThinking) return;

  if (currentVariant.draft) {
    if (!draftedThisTurn) {
      document.getElementById('parityHint').textContent = 'Draft from market first.';
      return;
    }
    if (!playerHands[currentPlayer].includes(n)) return;
  } else if (currentVariant.lanier) {
    if (!playerHands[currentPlayer].includes(n)) return;
  } else {
    if (usedNumbers.has(n)) return;
  }

  selectedNumber = (selectedNumber === n) ? null : n;
  refreshNumberSelectionUI();

  if (trySubmitSelectedMove()) return;

  if (selectedNumber != null && selectedCell == null) {
    document.getElementById('parityHint').textContent = 'Number selected. Tap a cell to place it.';
  } else {
    updateParityHint();
  }
}

function doPlaceNumber(cellId, n) {
  board[cellId] = n;
  usedNumbers.add(n);
  numberPlacements[n] = { cell: cellId, player: currentPlayer };

  document.querySelectorAll('.cell.last-move, .master-key-cell.last-move').forEach(el => el.classList.remove('last-move'));

  if (currentVariant.draft || currentVariant.lanier) {
    const hand = playerHands[currentPlayer];
    const idx = hand.indexOf(n);
    if (idx >= 0) hand.splice(idx, 1);
  }

  const el = getCellEl(cellId);
  if (el) {
    const hiddenMk = currentVariant.hiddenMaster && cellId === 'mk' && !gameOver;
    el.textContent = hiddenMk ? '?' : n;
    el.classList.remove('selected');
    el.classList.add('filled', 'cell-pop', 'last-move');
  }

  if (!currentVariant.draft && !currentVariant.lanier) {
    const numBtn = document.getElementById(`num-${n}`);
    if (numBtn) {
      numBtn.classList.add('used');
      if (isMasterCell(cellId)) numBtn.classList.add('mk-placed');
      else {
        const col = parseInt(cellId[3], 10);
        if (col === 0) numBtn.classList.add('p1-placed');
        else if (col === 1) numBtn.classList.add('p2-placed');
        else numBtn.classList.add('key-placed');
      }
    }
  }

  if (currentVariant.keyLock && cellId.startsWith('r') && parseInt(cellId[3], 10) === 2) {
    const row = parseInt(cellId[1], 10);
    rowLocks[row] = 2;
  }

  selectedCell = null;
  selectedNumber = null;
  refreshNumberSelectionUI();
  turnCount++;

  if (currentVariant.lanier) drawLanierHand(currentPlayer, 3);

  if (turnCount >= getAllCells().length) {
    gameOver = true;
    setTimeout(resolveGame, 350);
  } else {
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    draftedThisTurn = false;
    decrementLocks();
    refreshLockedCells();
    updateTurnBar();

    if (currentVariant.draft) renderDraftPicker();
    else if (currentVariant.lanier) renderLanierPicker();

    if (vsAI && currentPlayer === aiPlayer && !gameOver) triggerAIMove();
  }

  updateParityHint();
}

function decrementLocks() {
  if (!currentVariant.keyLock) return;
  rowLocks = rowLocks.map(v => Math.max(0, v - 1));
}

function refreshLockedCells() {
  if (!currentVariant.keyLock) return;
  for (let r = 0; r < currentVariant.rows; r++) {
    for (let c = 0; c < 2; c++) {
      const el = document.getElementById(`r${r}c${c}`);
      if (!el) continue;
      if (rowLocks[r] > 0 && board[`r${r}c${c}`] === undefined) el.classList.add('locked');
      else el.classList.remove('locked');
    }
  }
}

function triggerAIMove() {
  aiThinking = true;
  updateTurnBar();

  setTimeout(() => {
    aiThinking = false;

    if (currentVariant.draft) {
      const d = randPick(marketNumbers);
      draftNumber(d);
      const cells = getLegalEmptyCells();
      const hand = playerHands[currentPlayer];
      if (cells.length && hand.length) doPlaceNumber(randPick(cells), randPick(hand));
      return;
    }

    if (currentVariant.lanier) {
      const cells = getLegalEmptyCells();
      const hand = playerHands[currentPlayer];
      if (cells.length && hand.length) doPlaceNumber(randPick(cells), randPick(hand));
      return;
    }

    const move = getAIMove();
    doPlaceNumber(move.cell, move.num);
  }, 350);
}

function getLegalEmptyCells() {
  let cells = getAllCells().filter(c => board[c] === undefined && !isCellLocked(c));
  if (isSandkuhlerMasterForced(board, turnCount)) cells = cells.filter(c => c === 'mk');
  return cells;
}

function getAIMove() {
  const searchVariants = new Set(['classic', 'sandkuhler', 'dual-master', 'key-lock']);
  if (!searchVariants.has(currentVariant.id)) return getRandomMove();

  if (aiDifficulty === 'easy') return getRandomMove();
  if (aiDifficulty === 'medium') return getBestMove(2);

  const movesLeft = getAllCells().filter(c => board[c] === undefined).length;
  const depth = currentVariant.id === 'classic'
    ? (movesLeft <= 6 ? movesLeft : 3)
    : (movesLeft <= 5 ? movesLeft : 3);
  return getBestMove(depth);
}

function getRandomMove() {
  const emptyCells = getLegalEmptyCells();
  const availNums = getRemainingNumbers();
  return { cell: randPick(emptyCells), num: randPick(availNums) };
}

function getBestMove(maxDepth) {
  const emptyCells = getLegalEmptyCells();
  const availNums = getRemainingNumbers();
  const aiMaximizes = (aiPlayer === 2);
  let bestScore = aiMaximizes ? -Infinity : Infinity;
  let bestMove = null;

  for (const cell of emptyCells) {
    for (const num of availNums) {
      const nextBoard = { ...board, [cell]: num };
      const nextUsed = new Set(usedNumbers);
      nextUsed.add(num);
      const nextLocks = applyLocksAfterMove(rowLocks, cell);
      const score = minimaxVariant(maxDepth - 1, !aiMaximizes, -Infinity, Infinity, nextBoard, nextUsed, nextLocks);

      if (aiMaximizes ? score > bestScore : score < bestScore) {
        bestScore = score;
        bestMove = { cell, num };
      }
    }
  }

  return bestMove || getRandomMove();
}

function applyLocksAfterMove(locks, placedCell) {
  let nextLocks = [...locks];
  if (currentVariant.keyLock && placedCell.startsWith('r') && parseInt(placedCell[3], 10) === 2) {
    const row = parseInt(placedCell[1], 10);
    nextLocks[row] = 2;
  }
  if (currentVariant.keyLock) {
    nextLocks = nextLocks.map(v => Math.max(0, v - 1));
  }
  return nextLocks;
}

function getLegalCellsForState(simBoard, simLocks) {
  let cells = getAllCells().filter(c => {
    if (simBoard[c] !== undefined) return false;
    if (!currentVariant.keyLock || !c.startsWith('r')) return true;
    const row = parseInt(c[1], 10);
    const col = parseInt(c[3], 10);
    if (col === 2) return true;
    return (simLocks[row] || 0) === 0;
  });

  const placedCount = Object.values(simBoard).filter(v => v !== undefined).length;
  if (isSandkuhlerMasterForced(simBoard, placedCount)) cells = cells.filter(c => c === 'mk');
  return cells;
}

function getRowRuleForBoard(simBoard, r) {
  const keyVal = simBoard[`r${r}c2`];
  if (currentVariant.id === 'dual-master') {
    const mkId = keyVal % 2 === 1 ? 'mkOdd' : 'mkEven';
    const mkVal = simBoard[mkId];
    const parityMatch = (keyVal % 2) === (mkVal % 2);
    return { mkVal, mkLabel: mkId === 'mkOdd' ? 'MO' : 'ME', parityMatch };
  }

  if (currentVariant.id === 'key-sum-9') {
    const keyValues = Array.from({ length: currentVariant.rows }, (_, i) => simBoard[`r${i}c2`]);
    const keySum = keyValues.reduce((acc, v) => acc + (v || 0), 0);
    const parityMatch = (keyVal % 2) === (keySum % 2);
    return { mkVal: keySum, mkLabel: 'ΣK', parityMatch };
  }

  const mkVal = simBoard['mk'];
  const parityMatch = (keyVal % 2) === (mkVal % 2);
  return { mkVal, mkLabel: 'MK', parityMatch };
}

function evaluateTerminalForBoard(simBoard) {
  let p2Rows = 0;
  for (let r = 0; r < currentVariant.rows; r++) {
    const p1 = simBoard[`r${r}c0`];
    const p2 = simBoard[`r${r}c1`];
    const rr = getRowRuleForBoard(simBoard, r);
    const winner = rr.parityMatch ? (p1 < p2 ? 1 : 2) : (p1 > p2 ? 1 : 2);
    p2Rows += winner === 2 ? 1 : -1;
  }
  return p2Rows;
}

function evaluateHeuristicForBoard(simBoard) {
  let score = 0;

  for (let r = 0; r < currentVariant.rows; r++) {
    const p1 = simBoard[`r${r}c0`];
    const p2 = simBoard[`r${r}c1`];
    const key = simBoard[`r${r}c2`];

    if (p1 != null && p2 != null && key != null) {
      const mastersReady = currentVariant.id === 'dual-master'
        ? (simBoard['mkOdd'] != null && simBoard['mkEven'] != null)
        : currentVariant.id === 'key-sum-9'
          ? Array.from({ length: currentVariant.rows }, (_, i) => simBoard[`r${i}c2`]).every(v => v != null)
          : (simBoard['mk'] != null);
      if (mastersReady) {
        const rr = getRowRuleForBoard(simBoard, r);
        const winner = rr.parityMatch ? (p1 < p2 ? 1 : 2) : (p1 > p2 ? 1 : 2);
        score += winner === 2 ? 1 : -1;
      } else {
        score += (p2 > p1 ? 0.1 : -0.1);
      }
    } else if (p1 != null && p2 != null) {
      score += (p2 > p1 ? 0.12 : -0.12);
    } else if (p1 != null || p2 != null) {
      const val = p1 != null ? p1 : p2;
      const isP2 = p2 != null;
      const edge = (val >= Math.ceil(currentVariant.numbers * 0.7) || val <= Math.floor(currentVariant.numbers * 0.3)) ? 0.06 : 0;
      score += isP2 ? edge : -edge;
    }

    if (key != null) score += 0.02;
  }

  if (currentVariant.id === 'dual-master') {
    if (simBoard['mkOdd'] != null) score += 0.02;
    if (simBoard['mkEven'] != null) score += 0.02;
  } else if (currentVariant.id === 'key-sum-9') {
    const placedKeys = Array.from({ length: currentVariant.rows }, (_, i) => simBoard[`r${i}c2`]).filter(v => v != null).length;
    score += placedKeys * 0.01;
  } else {
    if (simBoard['mk'] != null) score += 0.03;
  }

  return score;
}

function minimaxVariant(depth, isMaximizing, alpha, beta, simBoard, simUsed, simLocks) {
  const movesLeft = getAllCells().filter(c => simBoard[c] === undefined).length;
  if (movesLeft === 0) return evaluateTerminalForBoard(simBoard);
  if (depth === 0) return evaluateHeuristicForBoard(simBoard);

  const emptyCells = getLegalCellsForState(simBoard, simLocks);
  const availNums = [];
  const { start, end } = getNumberRange();
  for (let i = start; i <= end; i++) if (!simUsed.has(i)) availNums.push(i);

  if (isMaximizing) {
    let best = -Infinity;
    for (const cell of emptyCells) {
      for (const num of availNums) {
        const nextBoard = { ...simBoard, [cell]: num };
        const nextUsed = new Set(simUsed);
        nextUsed.add(num);
        const nextLocks = applyLocksAfterMove(simLocks, cell);
        const score = minimaxVariant(depth - 1, false, alpha, beta, nextBoard, nextUsed, nextLocks);
        best = Math.max(best, score);
        alpha = Math.max(alpha, best);
        if (beta <= alpha) return best;
      }
    }
    return best;
  }

  let best = Infinity;
  for (const cell of emptyCells) {
    for (const num of availNums) {
      const nextBoard = { ...simBoard, [cell]: num };
      const nextUsed = new Set(simUsed);
      nextUsed.add(num);
      const nextLocks = applyLocksAfterMove(simLocks, cell);
      const score = minimaxVariant(depth - 1, true, alpha, beta, nextBoard, nextUsed, nextLocks);
      best = Math.min(best, score);
      beta = Math.min(beta, best);
      if (beta <= alpha) return best;
    }
  }
  return best;
}

function getRowRule(r) {
  return getRowRuleForBoard(board, r);
}

function resolveGame() {
  if (currentVariant.hiddenMaster) {
    const mkEl = document.getElementById('mk');
    if (mkEl) mkEl.textContent = board['mk'];
  }

  let p1Score = 0, p2Score = 0;
  const rowResults = [];

  for (let r = 0; r < currentVariant.rows; r++) {
    const p1Val = board[`r${r}c0`];
    const p2Val = board[`r${r}c1`];
    const keyVal = board[`r${r}c2`];
    const rr = getRowRule(r);

    const parityWinner = rr.parityMatch ? (p1Val < p2Val ? 1 : 2) : (p1Val > p2Val ? 1 : 2);
    const rowWinValue = parityWinner === 1 ? p1Val : p2Val;
    const parityPoints = currentVariant.id === 'hodgkins'
      ? 2
      : currentVariant.id === 'total-score'
        ? rowWinValue
        : 1;
    if (parityWinner === 1) p1Score += parityPoints; else p2Score += parityPoints;

    let closestWinner = null;
    let p1Dist = null;
    let p2Dist = null;
    if (currentVariant.id === 'hodgkins') {
      p1Dist = Math.abs(p1Val - keyVal);
      p2Dist = Math.abs(p2Val - keyVal);
      if (p1Dist < p2Dist) {
        closestWinner = 1;
        p1Score += 1;
      } else if (p2Dist < p1Dist) {
        closestWinner = 2;
        p2Score += 1;
      }
    }

    rowResults.push({
      row: r, p1Val, p2Val, keyVal,
      mk: rr.mkVal, mkLabel: rr.mkLabel,
      parityMatch: rr.parityMatch,
      winner: parityWinner,
      rule: rr.parityMatch ? 'lower wins' : 'higher wins',
      parityPoints,
      closestWinner,
      p1Dist,
      p2Dist
    });

    const p1Cell = document.getElementById(`r${r}c0`);
    const p2Cell = document.getElementById(`r${r}c1`);
    if (parityWinner === 1) {
      p1Cell.classList.add('row-win');
      p2Cell.classList.add('row-lose');
    } else {
      p2Cell.classList.add('row-win');
      p1Cell.classList.add('row-lose');
    }

    const ind = document.getElementById(`rowInd${r}`);
    if (ind) {
      ind.textContent = vsAI ? (parityWinner === aiPlayer ? 'AI' : 'YOU') : `P${parityWinner}`;
      ind.className = `row-ind-item show ${parityWinner === 1 ? 'p1w' : 'p2w'}`;
    }
  }

  showEndgame(p1Score, p2Score, rowResults);
}

function showEndgame(p1Score, p2Score, rowResults) {
  let overallWinner = null;
  if (p1Score > p2Score) overallWinner = 1;
  else if (p2Score > p1Score) overallWinner = 2;

  const title = document.getElementById('scoreboardTitle');
  const scoreLine = document.getElementById('scoreboardScore');

  if (overallWinner == null) {
    title.textContent = 'DRAW';
    title.style.color = 'var(--text)';
  } else {
    const winColor = overallWinner === 1 ? 'var(--p1)' : 'var(--p2)';
    if (vsAI) title.textContent = overallWinner === aiPlayer ? 'AI WINS' : 'YOU WIN!';
    else title.textContent = `PLAYER ${overallWinner} WINS!`;
    title.style.color = winColor;
  }

  const p1Label = vsAI ? (aiPlayer === 1 ? 'AI' : 'You') : 'P1';
  const p2Label = vsAI ? (aiPlayer === 2 ? 'AI' : 'You') : 'P2';
  scoreLine.textContent = `${p1Label} ${p1Score} — ${p2Label} ${p2Score}`;

  const breakdown = document.getElementById('endgameBreakdown');
  let html = '';
  for (const rr of rowResults) {
    const keyParity = rr.keyVal % 2 === 0 ? 'even' : 'odd';
    const mkParity = rr.mk % 2 === 0 ? 'even' : 'odd';
    const symbol = rr.parityMatch ? '=' : '≠';
    const rwLabel = vsAI ? (rr.winner === aiPlayer ? 'AI' : 'YOU') : `P${rr.winner}`;

    html += `<div class="breakdown-row">
      <span class="breakdown-label">Row ${rr.row + 1}</span>
      <span class="breakdown-rule">Key ${rr.keyVal}(${keyParity}) ${symbol} ${rr.mkLabel} ${rr.mk}(${mkParity}) → ${rr.rule}${rr.parityPoints > 1 ? ` (+${rr.parityPoints})` : ''}</span>
      <span class="breakdown-winner ${rr.winner === 1 ? 'bw-p1' : 'bw-p2'}">${rwLabel}</span>
    </div>`;

    if (currentVariant.id === 'hodgkins') {
      const closeLabel = rr.closestWinner == null
        ? 'TIE'
        : (vsAI ? (rr.closestWinner === aiPlayer ? 'AI' : 'YOU') : `P${rr.closestWinner}`);
      const closeClass = rr.closestWinner == null
        ? ''
        : (rr.closestWinner === 1 ? 'bw-p1' : 'bw-p2');
      html += `<div class="breakdown-row">
        <span class="breakdown-label">&nbsp;</span>
        <span class="breakdown-rule">Closest to Key: |${rr.p1Val}-${rr.keyVal}|=${rr.p1Dist}, |${rr.p2Val}-${rr.keyVal}|=${rr.p2Dist} → +1</span>
        <span class="breakdown-winner ${closeClass}">${closeLabel}</span>
      </div>`;
    }
  }
  breakdown.innerHTML = html;

  document.getElementById('turnBar').style.display = 'none';
  document.getElementById('variantDisplay').style.display = 'none';
  document.getElementById('scoreboard').classList.add('show');
  document.getElementById('boardContainer').classList.add('endgame');
  document.getElementById('parityHint').style.display = 'none';
  document.getElementById('pickerLabel').style.display = 'none';
  document.getElementById('numberPicker').style.display = 'none';
  document.getElementById('gameActions').style.display = 'none';
  breakdown.classList.add('show');
  document.getElementById('endgameActions').classList.add('show');
}

function hideEndgame() {
  document.getElementById('turnBar').style.display = '';
  document.getElementById('variantDisplay').style.display = '';
  document.getElementById('scoreboard').classList.remove('show');
  document.getElementById('boardContainer').classList.remove('endgame');
  document.getElementById('parityHint').style.display = '';
  document.getElementById('pickerLabel').style.display = '';
  document.getElementById('numberPicker').style.display = '';
  document.getElementById('gameActions').style.display = '';
  document.getElementById('endgameBreakdown').classList.remove('show');
  document.getElementById('endgameActions').classList.remove('show');
}

function updateTurnBar() {
  const bar = document.getElementById('turnBar');
  const text = document.getElementById('turnText');
  bar.className = `turn-bar p${currentPlayer}-turn`;

  if (aiThinking) {
    text.textContent = 'AI is thinking...';
    bar.classList.add('ai-thinking');
  } else if (vsAI) {
    text.textContent = currentPlayer === aiPlayer ? "AI's Turn" : 'Your Turn';
    bar.classList.remove('ai-thinking');
  } else {
    text.textContent = `Player ${currentPlayer}'s Turn`;
    bar.classList.remove('ai-thinking');
  }
}

function updateParityHint() {
  const hint = document.getElementById('parityHint');
  if (gameOver) {
    hint.style.display = 'none';
    return;
  }

  if (currentVariant.draft) {
    if (!draftedThisTurn) {
      hint.textContent = `Draft phase: pick one from market (${marketNumbers.join(', ')}), then place from your hand.`;
      return;
    }
    hint.textContent = `Place phase: choose a cell, then place from hand (${playerHands[currentPlayer].join(', ')}).`;
    return;
  }

  if (currentVariant.lanier) {
    hint.textContent = `Play from hand (${playerHands[currentPlayer].join(', ')}). Deck remaining: ${lanierDeck.length}.`;
    return;
  }

  if (isSandkuhlerMasterForced(board, turnCount)) {
    hint.textContent = 'Sandkühler rule: Master Key must be placed now.';
    return;
  }

  if (currentVariant.id === 'dual-master') {
    const mo = board['mkOdd'];
    const me = board['mkEven'];
    if (mo != null || me != null) {
      hint.textContent = `Odd keys use MASTER ODD (${mo ?? '?'}). Even keys use MASTER EVEN (${me ?? '?'}).`;
      return;
    }
  }

  if (currentVariant.id === 'key-sum-9') {
    const keyValues = Array.from({ length: currentVariant.rows }, (_, i) => board[`r${i}c2`]).filter(v => v != null);
    if (keyValues.length) {
      const keySum = keyValues.reduce((acc, v) => acc + v, 0);
      const sumParity = keySum % 2 === 0 ? 'even' : 'odd';
      hint.innerHTML = `Key-column sum is <span class="${sumParity === 'even' ? 'even' : 'odd'}">${keySum} (${sumParity})</span>. ` +
        `Each row compares its Key parity to this sum.`;
      return;
    }
  }

  if (currentVariant.hiddenMaster && board['mk'] != null) {
    hint.textContent = 'Master Key is hidden until the end. Plan for both parity outcomes.';
    return;
  }

  if (board['mk'] !== undefined) {
    const mkVal = board['mk'];
    const mkParity = mkVal % 2 === 0 ? 'even' : 'odd';
    hint.innerHTML = `Master Key is <span class="${mkParity === 'even' ? 'even' : 'odd'}">${mkVal} (${mkParity})</span>. ` +
      `Key matches → <span class="low">lower wins</span>. Key differs → <span class="high">higher wins</span>.`;
    return;
  }

  if (selectedCell) {
    if (isMasterCell(selectedCell)) hint.textContent = 'Placing in a Master Key cell.';
    else {
      const col = parseInt(selectedCell[3], 10);
      const colName = ['P1', 'P2', 'Key'][col];
      hint.textContent = `Placing in ${colName} column. Choose a number.`;
    }
    return;
  }

  if (currentVariant.keyLock) {
    hint.textContent = 'Tap a cell, then choose a number. Key placements lock that row for one opponent turn.';
  } else {
    hint.textContent = 'Tap a cell, then choose a number to place.';
  }
}

function renderHelpContent() {
  const title = document.getElementById('helpTitle');
  const body = document.getElementById('helpBody');
  const rows = currentVariant.rows;
  const needed = Math.floor(rows / 2) + 1;

  title.textContent = `How to Play — ${currentVariant.label}`;

  let variantBits = '';
  if (currentVariant.id === 'key-sum-9') {
    variantBits = `<h3>Variant Rule</h3>
      <p>There is no separate Master Key cell. Add all Key-column values; that sum parity is the master rule for every row.</p>`;
  } else if (currentVariant.id === 'total-score') {
    variantBits = `<h3>Variant Rule</h3>
      <p>Use normal row-winning rules, but scoring is by value: each won row contributes its winning P1/P2 number to your total.</p>
      <p>Highest total score wins (not most rows).</p>`;
  } else if (currentVariant.id === 'whiteacre') {
    variantBits = `<h3>Variant Rule</h3>
      <p>Uses normal Master Key scoring, but with numbers <strong>1-12</strong>. You fill 10 cells and <strong>2 numbers remain unplayed</strong>.</p>`;
  } else if (currentVariant.id === 'lanier') {
    variantBits = `<h3>Variant Rule</h3>
      <p>Numbers are card-based: values <strong>0-9</strong>. Each player plays from hand, then draws back up to <strong>3 cards</strong> after their turn.</p>
      <p>Special ability cards can be layered onto this format for extra tactical effects.</p>`;
  } else if (currentVariant.id === 'dual-master') {
    variantBits = `<h3>Variant Rule</h3>
      <p>There are two global master keys:</p>
      <ul style="margin: 6px 0 6px 16px;">
        <li><strong>MASTER ODD</strong> applies to rows with odd Key values</li>
        <li><strong>MASTER EVEN</strong> applies to rows with even Key values</li>
      </ul>`;
  } else if (currentVariant.id === 'key-lock') {
    variantBits = `<h3>Variant Rule</h3>
      <p>When a Key cell is filled, that row's P1/P2 cells are locked for exactly one opponent turn.</p>`;
  } else if (currentVariant.id === 'draft-place') {
    variantBits = `<h3>Variant Rule</h3>
      <p>Each turn has two phases: <strong>Draft</strong> one number from the market, then <strong>Place</strong> one number from your hand.</p>`;
  } else if (currentVariant.id === 'sandkuhler') {
    variantBits = `<h3>Variant Rule</h3>
      <p>Master Key cannot be the last cell filled. If still empty by turn 6, the current player must place it immediately.</p>`;
  } else if (currentVariant.id === 'hodgkins') {
    variantBits = `<h3>Variant Rule</h3>
      <p>Parity row wins are worth <strong>2 points each</strong> (6 total), and each row awards <strong>+1 point</strong> to the P1/P2 value closest to that row's Key (3 total).</p>
      <p>Most points wins (target is usually <strong>5+</strong> out of 9).</p>`;
  }

  const masterText = currentVariant.id === 'dual-master'
    ? 'Master Odd / Master Even'
    : 'Master Key';
  const setupRuleText = currentVariant.draft
    ? 'Numbers are drafted and then placed.'
    : currentVariant.lanier
      ? 'Use a 0-9 deck. Play from your hand, then draw back up to 3 cards at end of turn.'
      : currentVariant.id === 'key-sum-9'
        ? 'There is no master cell; Key-column sum parity controls row scoring rules.'
        : `The ${masterText} cell${currentVariant.id === 'dual-master' ? 's' : ''} control row scoring rules.`;

  const objectiveText = currentVariant.id === 'hodgkins'
    ? 'Score the most points (typically 5+ out of 9).'
    : currentVariant.id === 'total-score'
      ? 'Score the highest total of winning row values.'
      : `Win <strong>${needed} out of ${rows}</strong> rows.`;

  body.innerHTML = `
    <p><strong>Parity Twist</strong> is a 2-player strategy game. ${objectiveText}</p>
    <h3>Setup</h3>
    <p>The board has 3 columns: <span class="hl-p1">P1</span>, <span class="hl-p2">P2</span>, and <span class="hl-key">Key</span>, with ${rows} rows.
    ${setupRuleText}</p>

    <h3>Core Scoring Rule</h3>
    <ul style="margin: 6px 0 6px 16px;">
      <li><strong>Same parity</strong> between Key and active master rule &rarr; <em>lower</em> of P1/P2 wins the row</li>
      <li><strong>Different parity</strong> &rarr; <em>higher</em> of P1/P2 wins the row</li>
    </ul>
    ${variantBits}
  `;
}

function showHelp() {
  renderHelpContent();
  document.getElementById('helpOverlay').classList.add('show');
}

function hideHelp() {
  document.getElementById('helpOverlay').classList.remove('show');
}

function updateVariantButton() {
  const btn = document.getElementById('menuVariantBtn');
  if (!btn) return;
  const v = VARIANTS[selectedVariantId] || VARIANTS.classic;
  btn.textContent = `VARIANT: ${v.label.toUpperCase()}`;
}

let tappedVariantId = null;

function renderVariantChooser() {
  const list = document.getElementById('variantList');
  if (!list) return;
  list.innerHTML = '';

  for (const v of Object.values(VARIANTS)) {
    const isTapped = v.id === tappedVariantId;
    const isSelected = v.id === selectedVariantId;
    const card = document.createElement('div');
    card.className = `variant-card${isSelected ? ' active' : ''}`;
    card.onclick = () => {
      tappedVariantId = tappedVariantId === v.id ? null : v.id;
      renderVariantChooser();
    };

    let html = `<div class="variant-card-title">${v.label}${isSelected ? ' ✓' : ''}</div>`;
    html += `<div class="variant-card-desc">${v.desc}</div>`;
    if (isTapped && !isSelected) {
      html += `<button class="variant-select-btn" onclick="event.stopPropagation(); confirmVariant('${v.id}')">SELECT</button>`;
    }
    card.innerHTML = html;
    list.appendChild(card);
  }
}

function confirmVariant(id) {
  selectedVariantId = id;
  updateVariantButton();
  hideVariantChooser();
}

function showVariantChooser() {
  tappedVariantId = null;
  document.getElementById('variantScreen').classList.add('show');
  document.getElementById('menuVariantBtn').style.display = 'none';
  document.getElementById('menuVsBtn').style.display = 'none';
  document.getElementById('menuAIBtn').style.display = 'none';
  document.getElementById('difficultyPanel').style.display = 'none';
  document.getElementById('turnOrderPanel').style.display = 'none';
  renderVariantChooser();
}

function hideVariantChooser() {
  document.getElementById('variantScreen').classList.remove('show');
  document.getElementById('menuVariantBtn').style.display = '';
  document.getElementById('menuVsBtn').style.display = '';
  document.getElementById('menuAIBtn').style.display = '';
  document.getElementById('difficultyPanel').style.display = 'none';
  document.getElementById('turnOrderPanel').style.display = 'none';
}

function goToVariantScreen() {
  hideEndgame();
  updateVariantButton();
  document.getElementById('menuOverlay').classList.add('show');
  showVariantChooser();
}

function showMenu() {
  hideEndgame();
  hideVariantChooser();
  updateVariantButton();
  document.getElementById('menuOverlay').classList.add('show');
}

function showDifficulty() {
  hideVariantChooser();
  document.getElementById('difficultyPanel').style.display = 'flex';
  document.getElementById('menuAIBtn').style.display = 'none';
}

function selectDifficulty(diff) {
  selectedDiff = diff;
  document.getElementById('difficultyPanel').style.display = 'none';
  document.getElementById('turnOrderPanel').style.display = 'flex';
}

function startGame(ai, turnOrder) {
  currentVariant = VARIANTS[selectedVariantId] || VARIANTS.classic;

  vsAI = ai;
  if (vsAI) {
    aiDifficulty = selectedDiff;
    if (turnOrder === 'ai') aiPlayer = 1;
    else if (turnOrder === 'random') aiPlayer = Math.random() < 0.5 ? 1 : 2;
    else aiPlayer = 2;
  }

  document.getElementById('menuOverlay').classList.remove('show');
  const searchVariants = new Set(['classic', 'sandkuhler', 'dual-master', 'key-lock']);
  const aiNote = searchVariants.has(currentVariant.id) ? aiDifficulty.toUpperCase() : 'RANDOM';
  document.getElementById('subtitleText').textContent = vsAI
    ? `VS AI (${aiNote}) • ${currentVariant.label.toUpperCase()}`
    : `${currentVariant.label.toUpperCase()} • 2-PLAYER`;

  document.getElementById('variantDisplayName').textContent = currentVariant.label.toUpperCase();
  renderHelpContent();
  newGame();
}

function refillMarket() {
  if (!currentVariant.draft) return;
  const remaining = getRemainingNumbers().filter(n => !marketNumbers.includes(n) && !playerHands[1].includes(n) && !playerHands[2].includes(n));
  while (marketNumbers.length < 3 && remaining.length) {
    const pick = randPick(remaining);
    marketNumbers.push(pick);
    remaining.splice(remaining.indexOf(pick), 1);
  }
}

function shuffle(arr) {
  const out = [...arr];
  for (let i = out.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [out[i], out[j]] = [out[j], out[i]];
  }
  return out;
}

function drawLanierHand(player, target = 3) {
  if (!currentVariant.lanier) return;
  while (playerHands[player].length < target && lanierDeck.length) {
    playerHands[player].push(lanierDeck.pop());
  }
}

function newGame() {
  board = {};
  usedNumbers.clear();
  selectedCell = null;
  selectedNumber = null;
  currentPlayer = 1;
  turnCount = 0;
  gameOver = false;
  numberPlacements = {};
  aiThinking = false;
  rowLocks = Array(currentVariant.rows).fill(0);

  playerHands = { 1: [], 2: [] };
  marketNumbers = [];
  draftedThisTurn = false;
  lanierDeck = [];

  hideEndgame();
  buildGrid();
  buildMasterKeyArea();

  if (currentVariant.draft) {
    refillMarket();
    buildPicker();
  } else if (currentVariant.lanier) {
    const { start, end } = getNumberRange();
    const deckNums = [];
    for (let n = start; n <= end; n++) deckNums.push(n);
    lanierDeck = shuffle(deckNums);
    drawLanierHand(1, 3);
    drawLanierHand(2, 3);
    buildPicker();
  } else {
    buildPicker();
    document.getElementById('pickerLabel').textContent = 'AVAILABLE NUMBERS';
  }

  refreshNumberSelectionUI();

  const headers = document.querySelectorAll('.col-headers span');
  if (vsAI) {
    headers[0].textContent = aiPlayer === 1 ? 'AI' : 'YOU';
    headers[1].textContent = aiPlayer === 2 ? 'AI' : 'YOU';
  } else {
    headers[0].textContent = 'P1';
    headers[1].textContent = 'P2';
  }

  updateTurnBar();
  updateParityHint();

  if (vsAI && currentPlayer === aiPlayer) triggerAIMove();
}

init();
</script>
</body>
</html>
